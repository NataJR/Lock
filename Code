package ru.live.toofast.payment;


import java.util.Map;
import java.util.Random;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class PaymentTransferService {


    public PaymentTransferService(Map<Long, Lock> longAccountMap) {

    }

    static final class Account {
        private double balanceAmount;
        private final Lock lock = new ReentrantLock();
        private final Random number = new Random(123L);

        Account(double balance) {
            this.balanceAmount = balance;
        }

        private void depositAmount(Account ba, double amount)
                throws InterruptedException {
            while (true) {
                if (this.lock.tryLock()) {
                    try {
                        if (ba.lock.tryLock()) {
                            try {
                                if (amount > balanceAmount) {
                                    throw new IllegalArgumentException(
                                            "Transfer cannot be completed");
                                }
                                ba.balanceAmount += amount;
                                this.balanceAmount -= amount;
                                break;
                            } finally {
                                ba.lock.unlock();
                            }
                        }
                    } finally {
                        this.lock.unlock();
                    }
                }
                int n = number.nextInt(1000);
                int TIME = 1000 + n;
                Thread.sleep(TIME);
            }
        }

        public static void initiateTransfer(final Account first,
                                            final Account second, final double amount) {

            Thread transfer = new Thread(new Runnable() {
                public void run() {
                    try {
                        first.depositAmount(second, amount);
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                    }
                }
            });
            transfer.start();
        }
    }
}
